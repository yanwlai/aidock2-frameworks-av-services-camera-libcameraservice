/*
 * Copyright (C) 2026 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// 个人修改开始
#define LOG_TAG "AIDOCK_CAM_DECODER"
#include <utils/Log.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/stat.h>

#include "Camera3SocketServer.h"
#include "Camera3H264Decoder.h"

namespace android {
namespace camera3 {

// 个人修改开始
const char* Camera3SocketServer::kAbstractSocketName = "aidock_cam_h264";
// 个人修改结束

Camera3SocketServer::Camera3SocketServer() :
        Thread(false),
        mServerSocket(-1),
        mClientSocket(-1),
        mRunning(false) {
    mDecoder = new Camera3H264Decoder();
}

Camera3SocketServer::~Camera3SocketServer() {
    stop();
}

status_t Camera3SocketServer::start() {
    std::lock_guard<std::mutex> lock(mLock);
    if (mRunning) return OK;

    // 个人修改开始
    mServerSocket = socket(AF_UNIX, SOCK_STREAM, 0);
    if (mServerSocket < 0) {
        ALOGE("标记: 无法创建 Unix socket: %s", strerror(errno));
        return UNKNOWN_ERROR;
    }

    struct sockaddr_un serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sun_family = AF_UNIX;
    serv_addr.sun_path[0] = '\0';
    strncpy(serv_addr.sun_path + 1, kAbstractSocketName, sizeof(serv_addr.sun_path) - 2);

    socklen_t len = offsetof(struct sockaddr_un, sun_path) + 1 + strlen(kAbstractSocketName);

    if (bind(mServerSocket, (struct sockaddr *)&serv_addr, len) < 0) {
        ALOGE("标记: 抽象 Socket 绑定失败 (@%s): %s", kAbstractSocketName, strerror(errno));
        close(mServerSocket);
        mServerSocket = -1;
        return UNKNOWN_ERROR;
    }
    // 个人修改结束

    if (listen(mServerSocket, 1) < 0) {
        ALOGE("标记: 监听失败: %s", strerror(errno));
        close(mServerSocket);
        mServerSocket = -1;
        return UNKNOWN_ERROR;
    }

    if (mDecoder->initialize() != OK) {
        ALOGE("标记: 解码器初始化失败");
    }

    mRunning = true;
    run("Camera3SocketServer", PRIORITY_URGENT_DISPLAY);
    ALOGI("标记: Unix Domain Socket 服务器已在抽象命名空间 @%s 启动", kAbstractSocketName);

    return OK;
}

void Camera3SocketServer::stop() {
    {
        std::lock_guard<std::mutex> lock(mLock);
        if (!mRunning) return;
        mRunning = false;
    }

    if (mServerSocket != -1) {
        close(mServerSocket);
        mServerSocket = -1;
    }
    if (mClientSocket != -1) {
        close(mClientSocket);
        mClientSocket = -1;
    }

    requestExitAndWait();
    mDecoder->release();
    ALOGI("标记: Unix Domain Socket 服务器已停止");
}

bool Camera3SocketServer::threadLoop() {
    while (mRunning) {
        // 个人修改开始
        struct sockaddr_un cli_addr;
        socklen_t clilen = sizeof(cli_addr);
        
        ALOGI("标记: 等待抽象 Unix socket 客户端连接...");
        int newsockfd = accept(mServerSocket, (struct sockaddr *) &cli_addr, &clilen);
        // 个人修改结束
        
        if (newsockfd < 0) {
            if (mRunning) ALOGE("标记: accept 错误: %s", strerror(errno));
            continue;
        }

        {
            std::lock_guard<std::mutex> lock(mLock);
            if (mClientSocket != -1) {
                ALOGW("标记: 拒绝新的连接，已有客户端在连接中");
                close(newsockfd);
                continue;
            }
            mClientSocket = newsockfd;
        }

        ALOGI("标记: Unix socket 客户端已连接");
        handleClient();

        {
            std::lock_guard<std::mutex> lock(mLock);
            close(mClientSocket);
            mClientSocket = -1;
        }
        ALOGI("标记: Unix socket 客户端已断开");
    }
    return false;
}

void Camera3SocketServer::handleClient() {
    uint8_t buffer[65536];
    while (mRunning) {
        ssize_t n = read(mClientSocket, buffer, sizeof(buffer));
        if (n <= 0) {
            if (n < 0) ALOGE("标记: 读取错误: %s", strerror(errno));
            break;
        }

        ALOGV("标记: 收到 %zd 字节数据", n);
        parseAnnexB(buffer, n);
    }
}

// 简单的 Annex B 解析器逻辑
bool Camera3SocketServer::parseAnnexB(uint8_t* buffer, size_t size) {
    // 这里应该是将收到的字节流拼凑成 NAL 单元并送给解码器
    // 为了简化，我们假设一次发送一个完整的 NAL (T004 实现逻辑)
    // 实际应实现更完善的缓冲处理
    static std::vector<uint8_t> frameBuffer;
    
    for (size_t i = 0; i < size; ++i) {
        frameBuffer.push_back(buffer[i]);
        size_t len = frameBuffer.size();
        
        // 检测 start code (0x00000001)
        if (len >= 4 && 
            frameBuffer[len-4] == 0x00 && frameBuffer[len-3] == 0x00 &&
            frameBuffer[len-2] == 0x00 && frameBuffer[len-1] == 0x01) {
            
            if (len > 4) {
                // 发送之前的 NAL 单元（不含当前的 start code）
                size_t nalSize = len - 4;
                mDecoder->decode(frameBuffer.data(), nalSize);
                
                // 保留当前的 start code 为下一个 NAL 的开始
                std::vector<uint8_t> nextFrame;
                nextFrame.push_back(0x00);
                nextFrame.push_back(0x00);
                nextFrame.push_back(0x00);
                nextFrame.push_back(0x01);
                frameBuffer = nextFrame;
            }
        }
    }
    return true;
}

} // namespace camera3
} // namespace android
// 个人修改结束

